# SOLID 원칙
- 강수현

## 목차
- SOLID 원칙의 등장과 필요성
- 다섯가지 원칙 소개
1. SRP
2. OCP
3. LSP
4. ISP
5. DIP
- 도서관 시스템에서 SOLID 원칙에 어긋나는 부분 <br>
  코드와 이유

### SOLID 원칙의 등장과 필요성
객체지향 프로그래밍의 발전은 소프트웨어 개발에 있어 유지보수성과 확장성이라는 핵심 요소의 중요성을 부각시켰다. 초기 객체지향 개발은 코드의 재사용성과 직관적인 구조를 강조했지만 시간이 지나면서 클래스 간의 결합도 증가, 변경에 따른 연쇄적 오류 발생, 테스트의 복잡성 등 다양한 한계점이 드러났다. <br>
특히 프로젝트 규모가 커질수록 코드의 유연성과 안정성 확보가 어려워졌고 개발 생산성 저하와 품질 이슈로 이어졌다.<br>
이러한 문제를 해결하고 보다 견고하고 유연한 구조를 설계하기 위한 해결책으로 등장한 것이 SOLID 원칙이다. SOLID는 로버트 C. 마틴이 제안한 다섯 가지 객체지향 설계 원칙의 약자이다.
- SRP (Single Responsibility Principle): 하나의 클래스는 하나의 책임만 가져야 한다
- OCP (Open-Closed Principle): 소프트웨어 요소는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다
- LSP (Liskov Substitution Principle): 자식 클래스는 부모 클래스의 역할을 대체할 수 있어야 한다
- ISP (Interface Segregation Principle): 클라이언트는 자신이 사용하지 않는 메서드에 의존하지 않아야 한다
- DIP (Dependency Inversion Principle): 고수준 모듈은 저수준 모듈에 의존해서는 안 되며, 둘 다 추상화에 의존해야 한다 <br>

이 원칙들은 객체지향 설계에서 자주 발생하는 구조적 문제들을 예방하며 코드의 모듈화, 테스트 용이성, 유지보수성, 확장성을 향상시키는 데 큰 기여를 한다. 예를 들어 단일 책임 원칙을 따르면 클래스 하나가 여러 역할을 맡아 발생하는 변경 영향 범위를 줄일 수 있으며 개방-폐쇄 원칙을 적용하면 기존 코드를 손대지 않고도 새로운 기능을 추가할 수 있어 안정적인 확장이 가능해진다. <br>
### 다섯가지 원칙
<b> 1. SRP </b> <br>
SRP는 Single Responsibility Principle 의 약자로 <br>
단일 책임 원칙은 하나의 클래스는 하나의 책임만 가져야 한다는 객체지향 설계 원칙이다. 여기서 책임이란 클래스가 변경되어야 하는 이유를 의미한다.<br>
즉 하나의 클래스는 오직 하나의 변경 이유만을 가져야 하며 두 가지 이상의 책임을 가지게 되면 그 클래스는 향후 여러 방향으로 변경될 수 있기 대문에 불안정해진다. <br>
<b> 등장 배경 및 필요성 </b><br>
초기 객체지향 설계에서는 관련된 기능을 하나의 클래스로 묶는 경우가 많았다. 하지만 이 방식은 시간이 지나며 클래스의 역할이 모호해지고 기능이 늘어나며 유지보수가 어려워지는 문제를 초래했다.<br>
예를 들어 한 클래스가 비즈니스 로직과 UI 출력까지 모두 담당하면 출력 방식이 바뀔 때에도 비즈니스 로직이 영향을 받을 수 있다. 이처럼 변경이 불필요한 부분까지 영향을 받는 상황을 방지하기 위해 SRP가 등장하게 되었다. <br>
<b> SRP의 효과 </b><br>
1. 변경의 영향을 최소화하여 유지보수 용이성 향상 <br>
2. 클래스의 역할이 명확해져서 코드 가독성 증가 <br>
3. 테스트가 쉬워지고, 재사용성이 높아짐 <br>
4. 시스템의 확장 시 충돌 가능성 감소 <br>
SRP는 SOLID 원칙 중에서도 가장 기본이 되는 원칙이며 다른 원칙들과의 연결성도 높다. <br>
<br>
<b> 2. OCP </b> <br>
OCP는 Open-Closed Principle 의 약자로 <br>
개방-폐쇄 원칙은 새로운 기능이 필요할 때 기존 코드를 수정하지 않고 확장만으로 기능을 추가할 수 있어야 한다는 원칙이다 <br>
<b> 등장 배경 및 필요성 </b><br>
소프트웨어는 시간이 지나며 요구사항이 변하고 기능이 계속 추가된다. 이떄마다 기존 코드를 직접 수정하게 되면 <br>
> 예기치 않은 버그가 발생할 수 있고 이미 잘 작동하던 기능에도 영향을 줄 수 있다 <br>
OCP는 이런 문제를 방지하고 변경없이 기능을 확장할 수 있는 구조 설계를 가능하게 한다 <br>
유지보수성과 안정성이 중요한 대규모 시스템에서 매우 중요하다 <br>
<b> SRP의 효과 </b><br>
1. 기존 기능 안정성 유지 <br>
2. 유연한 확장이 가능하여 개발 속도와 품질 향상 <br>
3. 새로운 요구사항에도 안전하게 대응 가능 <br>
4. 모듈화된 구조로 테스트 및 유지보수 용이 <br>
<br>
<b> 3. LSP </b> <br>
LSP는 Liskov Substitution Principle 의 약자로 <br>
라스코프 치환 원칙은 자식 클래스는 부모 클래스의 기능을 대체할 수 있어야 하며 부모 클래스의 객체를 사용하는 코드에서 자식 클래스로 교체해도 정상적으로 동작해야 한다는 원칙이다 <br>
<b> 등장 배경 및 필요성 </b><br>
객체지향 설게에서 상속은 코드 재사용성과 확장성을 높이기 위한 도구로 자주 사용된다. 그러나 잘못된 상속 관계는 코드의 안정성을 해치고 예외 사황을 증가시킬 수 있다. <br>
LSP는 상속의 오용을 방지하고 신뢰할 수 있는 상속 구조를 만들기 위해 등장하였다.<br>
<b> LSP의 핵심 조건 </b><br>
1. 부모 클래스의 규약을 자식 클래스가 위반해서는 안 됨<br>
2. 자식 클래스는 부모 클래스의 기능을 최소한 동일하거나 더 나은 방식으로 수행해야 함<br>
3. 자식 클래스는 부모 클래스의 기대값(전제조건)을 강화하거나 결과(사후조건)를 약화시켜서는 안 됨<br>
<b> LSP의 효과 </b><br>
1. 신뢰할 수 있는 상속 구조 설계 가능<br>
2. 예외 상황과 버그 발생 가능성 감소 <br>
3. 부모-자식 클래스 간의 일관성 유지 <br>
4. 다형성을 안전하게 활용할 수 있음 <br>
LSP는 SOLID 원칙 중 상속 구조의 타당성을 점검할 수 있는 중요한 기준이다 <br>
<br>
<b> 4. ISP </b> <br>
ISP는 Interface Segregation Principle 의 약자로 <br>
인터페이스 분리 원칙은 하나의 커다란 범용 인터페이스보다 여러 개의 구체적이고 세분화된 인터페이스로 나누어야 하며 객체는 자신이 필요로 하는 기능에만 의존하도록 설계해야 한다는 원칙이다.<br>
<b> 등장 배경 및 필요성 </b><br>
인터페이스는 객체 간의 계약으로 다양한 클래스가 동일한 동작을 보장하도록 돕는다. 그러나 인터페이스에 너무 많은 기능을 포함시키면 일부 구현체는 필요 없는 메서드까지 구현해야 하며 이로 인해 불필요한 의존성, 가짜 구현, 유지보수의 어려움이 발생한다<br>
ISP는 이런 문제를 방지하고 인터페이스를 역할 단위로 분리하여 유연하고 명확한 구조를 갖도록 돕는다<br>
<b> ISP의 효과 </b><br>
1. 불필요한 의존 제거로 시스템의 복잡도 감소 <br>
2. 클래스가 자신의 책임에 집중할 수 있음 <br>
3. 재사용성과 테스트 용이성 향상 <br>
4. 기능 단위의 유연한 변경 및 확장 가능 <br>
인터페이스 분리 원칙은 작고 명확한 역할 중심의 설계를 가능하게 하며 SRP와 밀접한 연관이 있다 <br>
복잡하고 무거운 인터페이스가 아닌 역할 기반의 인터페이스 분리를 통해 객체 간 결합도를 낮추고 더 나은 모듈화를 이룰 수 있다<br>
이는 특히 인터페이스 기반 설계가 중요한 대규모 시스템에서 유효하다.<br>
<br>
<b> 5. DIP </b> <br>
DIP는 Dependency Inversion Principle의 약자로 <br>
구체적인 구현보다는 인터페이스나 추상 클래스에 의존하도록 구조를 설계해야 한다는 원칙이다 <br>
<b> 등장 배경 및 필요성 </b><br>
전통적인 구조에서는 고수준 모듈(비즈니스 로직)이 저수준 모듈(입출력, 데이터베이스 등)에 직접 의존하는 경우가 많다. 이 경우 하위 구현이 바뀌면 상위 모듈도 변경이 불가피해져 유지보수성이 크게 저하된다 <br>
DIP는 이러한 문제를 해결하고 시스템 구성 요소 간의 결합도를 낮춰서 변경이 강하고 유연한 아키텍처를 만드는 데 기여한다 <br>
<b> DIP 구현 방법 </b><br>
1. 인터페이스를 정의하여 추상화 중심의 설계 유도 <br>
2. 의존성 주입을 확용하여 실제 구현체를 외부에서 주입 <br>
3. IoC(제어의 역전) 패턴과도 밀접한 연관이 있음 <br>
<b> ISP의 효과 </b><br>
1. 구현 교체가 자유롭고 확장성과 유지보수성 향상 <br>
2. 상위 모듈이 하위 세부사항에 구애받지 않으므로 유연한 구조 설계 가능 <br>
3. 테스트 시 Mock 객체나 Stub 객체 주입이 쉬워짐 <br>
4. 모듈 간 결합도 감소, 재사용성 증가 
<br>
DIP는 확장 가능하고 테스트 가능한 아키텍처를 만들기 위한 핵심 원칙이며 현대 소프트웨어 개발에서 매우 중요한 설계 지침이다. <br>
SOLID 원칙의 마지막 항목이나 가장 전략적인 설계 기반이다. 